import AppKit
import SwiftUI
import Observation

// MARK: - KeyablePanel

private class KeyablePanel: NSPanel {
    override var canBecomeKey: Bool { true }
    var onEscape: (() -> Void)?

    override func cancelOperation(_ sender: Any?) {
        onEscape?()
    }
}

@MainActor
@Observable
final class PopupPanelController {
    private var panel: NSPanel?
    private var previousApp: NSRunningApplication?
    private var clickMonitor: Any?
    private var appDeactivationObserver: Any?
    var isVisible: Bool = false

    func toggle(clipboardManager: ClipboardManager) {
        if isVisible {
            close()
        } else {
            show(clipboardManager: clipboardManager)
        }
    }

    func show(clipboardManager: ClipboardManager) {
        guard !isVisible else { return }

        // パネル表示前の最前面アプリを記憶（自分自身は除外）
        let myBundleID = Bundle.main.bundleIdentifier
        let frontmost = NSWorkspace.shared.frontmostApplication
        if frontmost?.bundleIdentifier != myBundleID {
            previousApp = frontmost
        }

        let panelWidth: CGFloat = 380
        let panelHeight: CGFloat = 560

        let panel = KeyablePanel(
            contentRect: NSRect(x: 0, y: 0, width: panelWidth, height: panelHeight),
            styleMask: [.nonactivatingPanel, .titled, .fullSizeContentView],
            backing: .buffered,
            defer: false
        )

        panel.onEscape = { [weak self] in
            self?.close()
        }
        panel.isFloatingPanel = true
        panel.level = .floating
        panel.titleVisibility = .hidden
        panel.titlebarAppearsTransparent = true
        panel.isMovableByWindowBackground = true
        panel.backgroundColor = .clear
        panel.isOpaque = false
        panel.hasShadow = true
        panel.hidesOnDeactivate = false
        panel.collectionBehavior = [.canJoinAllSpaces, .fullScreenAuxiliary]

        let contentView = PopupContentView(
            clipboardManager: clipboardManager,
            onDismiss: { [weak self] in
                self?.close()
            },
            onPaste: { [weak self] in
                self?.closeAndPaste()
            }
        )
        panel.contentView = NSHostingView(rootView: contentView)

        self.panel = panel
        self.isVisible = true

        let mousePoint = NSEvent.mouseLocation
        let panelOrigin = Self.panelOrigin(anchor: mousePoint, panelWidth: panelWidth, panelHeight: panelHeight)
        panel.setFrameOrigin(panelOrigin)
        panel.makeKeyAndOrderFront(nil)
        setupClickMonitor()
        setupDeactivationObserver()
    }

    func close() {
        if let monitor = clickMonitor {
            NSEvent.removeMonitor(monitor)
            clickMonitor = nil
        }
        if let observer = appDeactivationObserver {
            NSWorkspace.shared.notificationCenter.removeObserver(observer)
            appDeactivationObserver = nil
        }
        panel?.orderOut(nil)
        panel = nil
        isVisible = false
    }

    func closeAndPaste() {
        let targetApp = previousApp
        close()

        guard let targetApp else { return }
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
            targetApp.activate()
            self.performPaste(targetPID: targetApp.processIdentifier, attempt: 0)
        }
    }

    private func performPaste(targetPID: pid_t, attempt: Int) {
        let maxAttempts = 10
        let delay = 0.05

        DispatchQueue.main.asyncAfter(deadline: .now() + delay) {
            let frontPID = NSWorkspace.shared.frontmostApplication?.processIdentifier

            if frontPID != targetPID, attempt < maxAttempts {
                self.performPaste(targetPID: targetPID, attempt: attempt + 1)
                return
            }

            Self.tryPaste(targetPID: targetPID)
        }
    }

    private static func tryPaste(targetPID: pid_t) {
        postPasteEvent()
    }

    // MARK: - Paste Event Fallback

    private static func postPasteEvent() {
        guard let keyDown = CGEvent(keyboardEventSource: nil, virtualKey: 0x09, keyDown: true),
              let keyUp = CGEvent(keyboardEventSource: nil, virtualKey: 0x09, keyDown: false) else { return }
        keyDown.flags = .maskCommand
        keyUp.flags = .maskCommand
        keyDown.post(tap: .cghidEventTap)
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
            keyUp.post(tap: .cghidEventTap)
        }
    }

    // MARK: - Panel Positioning

    private static func panelOrigin(anchor: NSPoint, panelWidth: CGFloat, panelHeight: CGFloat) -> NSPoint {
        var origin = NSPoint(x: anchor.x, y: anchor.y - panelHeight)

        if let screen = NSScreen.screens.first(where: { $0.frame.contains(anchor) }) ?? NSScreen.main {
            let visibleFrame = screen.visibleFrame
            if origin.x < visibleFrame.minX { origin.x = visibleFrame.minX }
            if origin.x + panelWidth > visibleFrame.maxX { origin.x = visibleFrame.maxX - panelWidth }
            if origin.y < visibleFrame.minY { origin.y = visibleFrame.minY }
            if origin.y + panelHeight > visibleFrame.maxY { origin.y = visibleFrame.maxY - panelHeight }
        }

        return origin
    }

    private func setupClickMonitor() {
        guard clickMonitor == nil else { return }
        clickMonitor = NSEvent.addGlobalMonitorForEvents(matching: [.leftMouseDown, .rightMouseDown]) { [weak self] _ in
            self?.close()
        }
    }

    private func setupDeactivationObserver() {
        guard appDeactivationObserver == nil else { return }
        appDeactivationObserver = NSWorkspace.shared.notificationCenter.addObserver(
            forName: NSWorkspace.didActivateApplicationNotification,
            object: nil, queue: .main
        ) { [weak self] notification in
            guard let app = notification.userInfo?[NSWorkspace.applicationUserInfoKey] as? NSRunningApplication,
                  app.bundleIdentifier != Bundle.main.bundleIdentifier else { return }
            MainActor.assumeIsolated {
                self?.close()
            }
        }
    }

}
